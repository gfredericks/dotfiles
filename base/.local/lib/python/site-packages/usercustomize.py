"""my user utilities; installed at builtins.__ so they can be accessed without importing anything

__.pdb() calls pdb.set_trace()

The following modules can be accessed at __.$module_name:

- inspect
- json
- os
- pprint
- re
- sys
"""
import builtins
import inspect
import json
import os
import os.path
import pprint
import pdb as pdb_
import re
import sys
import code
import rlcompleter
import traceback
import warnings
import threading
import time
import signal

builtins.__ = sys.modules[__name__]

pdb = pdb_.set_trace
def exit(n=42):
    os._exit(n)

_local_file = "_/usercustomize_local.py"

if(os.path.exists(_local_file)):
    print(f"Loading {_local_file}", file=sys.stderr)
    sys.path.append("_")
    import usercustomize_local

# TODO: add something for monkeypatching

# # this is slow, so just launch a thread to do it ten seconds later
# def configure_pandas():
#     time.sleep(10)
#     try:
#         import pandas
#         pandas.set_option('display.max_rows', 250)
#         pd.set_option('display.float_format',str)
#     except:
#         pass
# pandas_thread = threading.Thread(target=configure_pandas, daemon=True)
# pandas_thread.start()

class InteractiveConsole(code.InteractiveConsole):
    def raw_input(self, prompt=''):
        print(prompt, end='', flush=True)
        # how can we emulate input() but using /dev/tty?
        with open('/dev/tty','r') as f:
            line = f.readline()
            if line == 'exit' or line == 'exit\n':
                raise EOFError()
            return line

try:
    import readline
    def console():
        """
        Opens interactive console with current execution state.
        Call it with: `console.open(globals(), locals())`
        """
        frame = inspect.stack()[1].frame
        context = frame.f_globals.copy()
        context.update(frame.f_locals)
        readline.set_completer(rlcompleter.Completer(context).complete)
        readline.parse_and_bind("tab: complete")
        shell = InteractiveConsole(context)
        # the invisible characters here seem to mess up certain
        # operations
        # sys.ps1 = '\u001b[34;1m>>> \u001b[0m'
        sys.ps1 = '>>> '
        shell.interact(banner="<<--------------CONSOLE---------------->>", exitmsg="bye")
except:
    pass

# thanks https://stackoverflow.com/questions/22373927/get-traceback-of-warnings
def warn_with_traceback(message, category, filename, lineno, file=None, line=None):

    log = file if hasattr(file,'write') else sys.stderr
    traceback.print_stack(file=log)
    log.write(warnings.formatwarning(message, category, filename, lineno, line))

warnings.showwarning_orig = warnings.showwarning
warnings.showwarning = warn_with_traceback


import threading, traceback, sys, time

def print_stacks_from_thread(*sleep_times):

    def run_in_thread(*sleep_times):
        while len(sleep_times) > 0:
            time.sleep(sleep_times[0])
            sleep_times = sleep_times[1:]

            print("========== Current stacks[{}] ==========".format(os.getpid()))

            for th in threading.enumerate():
                print(th)
                traceback.print_stack(sys._current_frames()[th.ident])
                print()

    t = threading.Thread(target=run_in_thread, args=sleep_times)
    t.start()


def dump_all_stacks(file):
    for th in threading.enumerate():
        stack = sys._current_frames().get(th.ident)
        if stack:
            print(th, file=file)
            traceback.print_stack(stack, file=file)
            print("", file=file)

def dump_stacks_regularly():

    def run_in_thread():
        while True:
            with open(f"stacks.{os.getpid()}.txt", 'w') as f:
                dump_all_stacks(f)
            time.sleep(60)

    t = threading.Thread(target=run_in_thread, args=(), daemon=True)
    t.start()

def print_stack_trace(t=None):
    if t is None:
        t = threading.current_thread()
    traceback.print_stack(sys._current_frames()[t.ident])

pst = print_stack_trace

# just like the JVM
signal.signal(signal.SIGQUIT, lambda arg1, arg2: dump_all_stacks(sys.stdout))
